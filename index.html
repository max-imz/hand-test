<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Miroir Main 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #container { position: absolute; width: 100%; height: 100%; }
        #sizeControl {
            position: absolute; 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%);
            z-index: 100;
            color: white;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="sizeControl">
        Taille main: <input type="range" min="0.1" max="1" step="0.05" value="0.3" id="sizeSlider">
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // 1. Setup ThreeJS
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // 2. Chargement modèle 3D
        let handModel;
        new THREE.GLTFLoader().load(
            './hand.gltf',
            (gltf) => {
                handModel = gltf.scene;
                handModel.scale.set(0.3, 0.3, 0.3); // TAILLE INITIALE
                handModel.rotation.x = Math.PI; // FLIP VERTICAL (obligatoire)
                scene.add(handModel);
            }
        );

        // 3. Détection des mains
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.8,
            minTrackingConfidence: 0.8
        });

        // 4. Logique de suivi MIRROIR
        hands.onResults((results) => {
            if (!handModel || !results.multiHandLandmarks?.[0]) return;

            const landmarks = results.multiHandLandmarks[0];
            const wrist = landmarks[0];

            // POSITION (miroir parfait)
            handModel.position.set(
                (wrist.x - 0.5) * 10, // X
                -(wrist.y - 0.5) * 10, // Y (inversé)
                0 // Z
            );

            // ROTATION (calcul ultra-précis)
            const indexBase = landmarks[5];
            const pinkyBase = landmarks[17];
            const middleBase = landmarks[9];

            const palmNormal = new THREE.Vector3()
                .crossVectors(
                    new THREE.Vector3(pinkyBase.x - indexBase.x, pinkyBase.y - indexBase.y, 0),
                    new THREE.Vector3(middleBase.x - wrist.x, middleBase.y - wrist.y, 0)
                )
                .normalize();

            handModel.quaternion.setFromUnitVectors(
                new THREE.Vector3(0, 1, 0), // Orientation originale
                new THREE.Vector3(palmNormal.x, palmNormal.y, palmNormal.z) // Orientation réelle
            );
        });

        // 5. Contrôle de la taille
        document.getElementById('sizeSlider').addEventListener('input', (e) => {
            if (handModel) {
                const size = parseFloat(e.target.value);
                handModel.scale.set(size, size, size);
            }
        });

        // 6. Caméra
        const video = document.createElement('video');
        new Camera(video, {
            onFrame: async () => await hands.send({ image: video }),
            width: 1280,
            height: 720,
            facingMode: 'user'
        }).start();

        // 7. Animation
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
