<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Main 3D Tracking</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #111; }
        #container { position: absolute; width: 100vw; height: 100vh; }
        #status { 
            position: absolute; top: 10px; left: 10px; 
            color: white; background: rgba(0,0,0,0.7); 
            padding: 10px; font-family: Arial;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="status">Chargement...</div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // 1. Initialisation Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 2;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // Lumière
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        // 2. Chargement du modèle GLTF
        const loader = new THREE.GLTFLoader();
        let handModel;
        
        loader.load(
            './hand.gltf',  // Chemin relatif
            (gltf) => {
                handModel = gltf.scene;
                handModel.scale.set(0.1, 0.1, 0.1);
                scene.add(handModel);
                document.getElementById('status').textContent = "Prêt - Montrez votre main";
                console.log("Modèle chargé :", gltf);
                
                // Debug : Affiche les noms des os
                handModel.traverse((node) => {
                    if (node.isBone) console.log("Os trouvé :", node.name);
                });
            },
            undefined,
            (error) => {
                console.error("Erreur de chargement :", error);
                document.getElementById('status').textContent = 
                    `Erreur : ${error.message || "Vérifiez que hand.gltf existe"}`;
                
                // Fallback : Cube rouge si échec
                const cube = new THREE.Mesh(
                    new THREE.BoxGeometry(),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                scene.add(cube);
            }
        );

        // 3. Configuration MediaPipe
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks?.length > 0 && handModel) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Position 3D (coordonnées normalisées)
                const palmX = (landmarks[0].x - 0.5) * 3;
                const palmY = -(landmarks[0].y - 0.5) * 3;
                
                handModel.position.set(palmX, palmY, 0);
                
                // Rotation basée sur l'orientation de la main
                const wrist = landmarks[0];
                const middle = landmarks[9];
                handModel.rotation.z = Math.atan2(middle.y - wrist.y, middle.x - wrist.x) - Math.PI/2;
            }
        });

        // 4. Gestion de la caméra
        const video = document.createElement('video');
        video.style.display = 'none';
        document.body.appendChild(video);
        
        function startCamera() {
            new Camera(video, {
                onFrame: async () => {
                    try {
                        await hands.send({ image: video });
                    } catch (e) {
                        console.error("Erreur caméra :", e);
                    }
                },
                width: 640,
                height: 480
            }).start().catch(e => {
                console.error("Échec caméra :", e);
                document.getElementById('status').textContent = 
                    "Erreur : Autorisez la caméra et rechargez la page";
            });
        }

        // Démarrer après un délai
        setTimeout(startCamera, 1000);

        // 5. Animation
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
