<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Main 3D Tracking - Version corrigée</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #111; }
        #container { position: absolute; width: 100vw; height: 100vh; }
        #status {
            position: absolute; top: 10px; left: 10px;
            color: white; background: rgba(0,0,0,0.7);
            padding: 10px; font-family: Arial;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="status">Initialisation...</div>
    <video id="video" autoplay playsinline style="display:none;"></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // 1. INITIALISATION THREE.JS
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 10);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // Lumière améliorée
        const light1 = new THREE.DirectionalLight(0xffffff, 1.5);
        light1.position.set(1, 1, 1);
        scene.add(light1);
        scene.add(new THREE.AmbientLight(0x404040));

        // 2. CHARGEMENT DU MODÈLE AVEC CORRECTIONS
        const loader = new THREE.GLTFLoader();
        let handModel, mixer;
        const bones = {};

        loader.load('./hand.gltf', (gltf) => {
            handModel = gltf.scene;
            
            // Ajustements critiques
            handModel.scale.set(0.8, 0.8, 0.8); // Échelle légèrement réduite
            handModel.rotation.set(Math.PI/2, 0, 0); // Rotation initiale importante
            
            // Récupération des bones avec vérification
            handModel.traverse(child => {
                if (child.isBone) {
                    bones[child.name] = child;
                    // Réinitialisation des rotations pour éviter les déformations
                    child.rotation.set(0, 0, 0);
                    child.updateMatrixWorld();
                }
            });

            scene.add(handModel);
            document.getElementById('status').textContent = "Prêt - Montrez votre main";
            
        }, undefined, (error) => {
            console.error("Erreur de chargement:", error);
            document.getElementById('status').textContent = "Erreur: Modèle non chargé";
        });

        // 3. MÉDIAPIPE HANDS AVEC CONFIGURATION OPTIMISÉE
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // Réduit la complexité pour plus de stabilité
            minDetectionConfidence: 0.8,
            minTrackingConfidence: 0.8
        });

        // 4. MAPPING DES DOIGTS CORRIGÉ
        const fingerJoints = {
            thumb: {
                points: [1, 2, 3, 4],
                bones: ["thumb_baseR_03", "thumb_01R_08", "thumb_02R_09", "thumb_03R_010"]
            },
            index: {
                points: [5, 6, 7, 8],
                bones: ["index_baseR_012", "index_01R_017", "index_02R_018", "index_03R_019"]
            },
            middle: {
                points: [9, 10, 11, 12],
                bones: ["middle_baseR_020", "middle_01R_025", "middle_02R_026", "middle_03R_027"]
            },
            ring: {
                points: [13, 14, 15, 16],
                bones: ["ring_baseR_028", "ring_01R_033", "ring_02R_034", "ring_03R_035"]
            },
            pinky: {
                points: [17, 0, 18, 19],
                bones: ["pinky_baseR_036", "pinky_01R_041", "pinky_02R_042", "pinky_03R_043"]
            }
        };

        // 5. FONCTION DE TRACKING CORRIGÉE
        hands.onResults((results) => {
            if (!handModel || !results.multiHandLandmarks?.[0]) return;
            
            const landmarks = results.multiHandLandmarks[0];
            const wrist = landmarks[0];

            // Position globale avec lissage
            handModel.position.lerp(
                new THREE.Vector3(
                    (wrist.x - 0.5) * 4,
                    -(wrist.y - 0.5) * 4,
                    0
                ),
                0.3
            );

            // Rotation de la main corrigée
            const indexBase = landmarks[5];
            const pinkyBase = landmarks[17];
            
            const palmNormal = new THREE.Vector3()
                .crossVectors(
                    new THREE.Vector3(
                        pinkyBase.x - indexBase.x,
                        pinkyBase.y - indexBase.y,
                        pinkyBase.z - indexBase.z
                    ),
                    new THREE.Vector3(
                        wrist.x - indexBase.x,
                        wrist.y - indexBase.y,
                        wrist.z - indexBase.z
                    )
                )
                .normalize();

            handModel.quaternion.setFromUnitVectors(
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(palmNormal.x, -palmNormal.y, palmNormal.z)
            );

            // Animation des doigts avec vérification des bones
            Object.values(fingerJoints).forEach(finger => {
                for (let i = 0; i < finger.points.length - 1; i++) {
                    const bone = bones[finger.bones[i]];
                    if (!bone) continue;
                    
                    const start = landmarks[finger.points[i]];
                    const end = landmarks[finger.points[i + 1]];
                    
                    const direction = new THREE.Vector3(
                        end.x - start.x,
                        -(end.y - start.y),
                        end.z - start.z
                    ).normalize();
                    
                    // Rotation sécurisée avec vérification
                    if (direction.length() > 0) {
                        bone.quaternion.setFromUnitVectors(
                            new THREE.Vector3(0, 1, 0),
                            direction
                        );
                    }
                }
            });
        });

        // 6. INITIALISATION CAMÉRA
        const video = document.getElementById('video');
        const cameraMP = new Camera(video, {
            onFrame: async () => {
                try {
                    await hands.send({ image: video });
                } catch (e) {
                    console.error("Erreur caméra:", e);
                }
            },
            width: 640,
            height: 480,
            facingMode: 'user'
        });

        cameraMP.start().catch(e => {
            console.error("Erreur démarrage caméra:", e);
            document.getElementById('status').textContent = "Erreur: Caméra non disponible";
        });

        // 7. ANIMATION
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Gestion du redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
