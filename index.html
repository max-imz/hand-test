<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Synchronisation Doigt 3D</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
        #container { width: 100vw; height: 100vh; }
        #status { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 10px; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="status">Chargement du modèle...</div>
    <video id="video" autoplay playsinline style="display:none;"></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 2;
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);

    let model, bones = {};
    const loader = new THREE.GLTFLoader();

    loader.load('./hand.gltf', (gltf) => {
        model = gltf.scene;
        scene.add(model);

        // Identifier les bones par nom
        model.traverse(obj => {
            if (obj.isBone) {
                if (obj.name === 'index_01R_017') bones.index1 = obj;
                if (obj.name === 'index_02R_018') bones.index2 = obj;
                if (obj.name === 'index_03R_019') bones.index3 = obj;
            }
        });

        if (bones.index1 && bones.index2 && bones.index3) {
            document.getElementById('status').innerText = "Modèle prêt, montre ta main";
        } else {
            document.getElementById('status').innerText = "Erreur : Bones index manquants";
        }
    }, undefined, (err) => {
        console.error('Erreur chargement modèle:', err);
        document.getElementById('status').innerText = "Erreur chargement modèle";
    });

    // MediaPipe Hands
    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7,
        selfieMode: true
    });

    hands.onResults((results) => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0 && model) {
            const landmarks = results.multiHandLandmarks[0];
            const joints = [
                landmarks[5],  // index base
                landmarks[6],  // index PIP
                landmarks[7],  // index DIP
                landmarks[8]   // index tip
            ];

            for (let i = 0; i < 3; i++) {
                const start = joints[i];
                const end = joints[i+1];
                const startVec = new THREE.Vector3(start.x, -start.y, start.z);
                const endVec = new THREE.Vector3(end.x, -end.y, end.z);
                const dir = new THREE.Vector3().subVectors(endVec, startVec).normalize();
                const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                const bone = i === 0 ? bones.index1 : i === 1 ? bones.index2 : bones.index3;
                if (bone) {
                    bone.quaternion.slerp(quat, 0.5); // adoucir le mouvement
                }
            }
        }
    });

    const videoElement = document.getElementById('video');
    const cameraFeed = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({ image: videoElement });
        },
        width: 640,
        height: 480
    });
    cameraFeed.start().catch(err => {
        console.error('Erreur accès caméra:', err);
        document.getElementById('status').innerText = "Erreur accès caméra";
    });

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    </script>
</body>
</html>
